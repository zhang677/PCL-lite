test_name: G_0_6_02
inputs:
  - name: E0
    dtype: fp32
    dims: [K, M, N]
    data_gen: torch.rand
  - name: E1
    dtype: fp32
    dims: [K, N]
    data_gen: torch.rand

fns:
  - name: Mul
    apply: |
      return [input[0] * input[1]]
    input_dtype: [fp32, fp32]
    output_dtype: fp32
    func_name: fn_mul
  - name: Add
    apply: |
      return [state[0] + input[0]]
    init: [0]
    input_dtype: fp32
    output_dtype: fp32
    func_name: fn_add

outputs:
  - name: S0
    dtype: fp32
    dims: [M, N]
    data_transform:
    - |
      (input_data['E0'] * input_data['E1'].unsqueeze(1).repeat(1, M_value, 1)).sum(2)

impl: |
  E2 = step.Bufferize(a=1).apply(E1)
  E3 = step.Repeat(n=M).apply(E2)
  E4 = step.Streamify().apply(E3)
  E5 = step.Zip().apply((E0, E4))
  E6 = step.Map(fn=fn_mul).apply(E5)
  E7 = step.Accum(fn=fn_add, b=1).apply(E6)
  return E7

