test_name: G_0_3_04
global: |
  E_value = 2
  ctx[E] = E_value
  sigmoid = torch.nn.Sigmoid()
  silu = torch.nn.SiLU()

inputs:
  - name: E0
    dtype: fp32
    dims: [D, N, M]
    data_gen: torch.randn

parameters:
  - name: Wa_0
    dtype: fp32
    dims: [K, D]
    data_gen: torch.randn
  - name: Wa_1
    dtype: fp32
    dims: [K]
    data_gen: torch.randn

fns:
  - name: Score
    apply: |
      return [sigmoid((silu(input[0] @ input_data['Wa_0'])) @ input_data['Wa_1'])]
    input_dtype: Buffer(fp32, [D])
    output_dtype: fp32
    func_name: fn_score
  - name: Filter
    apply: |
      return [torch.tensor([1.0, 0.0])] if (input[0] > 0.5) else [torch.tensor([0.0, 1.0])]
    input_dtype: fp32
    output_dtype: Multihot(fp32, E)
    func_name: fn_filter

outputs:
  - name: S0
    dtype: Multihot(fp32, E)
    dims: [N, M]
    data_transform: 
      - |
        E0_data = input_data['E0']
        logits = (sigmoid(silu(E0_data @ input_data['Wa_0']) @ input_data['Wa_1']) > 0.5).float()
        torch.stack([logits, 1 - logits], dim=-1)

impl: |
  E1 = step.Bufferize(a=1).apply(E0)
  E2 = step.Map(fn=fn_score).apply(E1)
  E3 = step.Map(fn=fn_filter).apply(E2)
  return E3