test_name: G_0_12_01
global: |
  E_value = 2
  ctx[E] = E_value
  sigmoid = torch.nn.Sigmoid()
  gelu = torch.nn.GELU()

inputs:
  - name: E0
    dtype: fp32
    dims: [K, M]
    data_gen: torch.randn

parameters:
  - name: Wg
    dtype: fp32
    dims: [K]
    data_gen: torch.randn
  - name: W
    dtype: fp32
    dims: [K, K]
    data_gen: torch.randn
  
fns:
  - name: Gate
    apply: |
      return [sigmoid(input[0] @ input_data['Wg'])]
    input_dtype: Buffer(fp32, [K])
    output_dtype: fp32
    func_name: fn_gate
  
  - name: Top3
    apply: |
      _, indices = torch.topk(input[0], 3, dim=0)
      multihot = torch.zeros_like(input[0], dtype=torch.float32)
      multihot.scatter_(0, indices, 1.0)
      return [multihot]
    input_dtype: Buffer(fp32, [M])
    output_dtype: Buffer(fp32, [M])
    func_name: fn_top3
  
  - name: Expert0
    apply: |
      return [gelu(input[0] @ input_data['W']) * input[1] + input[0]]
    input_dtype: ["Buffer(fp32, [K])", fp32]
    output_dtype: Buffer(fp32, [K])
    func_name: fn_expert0
  
  - name: Expert1
    apply: |
      return [input[0]]
    input_dtype: ["Buffer(fp32, [K])", fp32]
    output_dtype: Buffer(fp32, [K])
    func_name: fn_expert1
  
  - name: Sum
    apply: |
      return [input[0] + state[0]]
    init: [0]
    input_dtype: Buffer(fp32, [K])
    output_dtype: Buffer(fp32, [K])
    func_name: fn_sum

  - name: Filter
    apply: |
      return [torch.tensor([1.0, 0.0])] if (input[0] == 1.0) else [torch.tensor([0.0, 1.0])]
    input_dtype: fp32
    output_dtype: Multihot(fp32, E)
    func_name: fn_filter
  
outputs:
  - name: S0
    dtype: Buffer(fp32, [K])
    dims: [M]
    data_transform:
      - |
        E0_data = input_data['E0']
        affinity = sigmoid(E0_data @ input_data['Wg']) # [M]
        _, indices = torch.topk(affinity, 3, dim=0)
        multihot = torch.zeros_like(affinity, dtype=torch.float32)
        score = multihot.scatter(0, indices, 1.0).unsqueeze(-1) # [M]
        (affinity.unsqueeze(-1) * (gelu(E0_data @ input_data['W'])) + E0_data) * score + E0_data * (1 - score)